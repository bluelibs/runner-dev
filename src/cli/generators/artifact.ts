import fs from "fs";
import fsp from "fs/promises";
import path from "path";
import { ArtifactKind, toCamelCase, toKebabCase, toPascalCase } from "./common";
import {
  eventTemplate,
  hookTemplate,
  resourceMiddlewareTemplate,
  resourceTemplate,
  tagTemplate,
  taskMiddlewareTemplate,
  taskTemplate,
} from "./templates";

export type ArtifactArgs = {
  kind: Exclude<ArtifactKind, "project">;
  name: string;
  namespace: string;
  baseDir: string;
  dryRun?: boolean;
  addIndex?: boolean;
  explicitId?: string;
  force?: boolean;
};

export async function scaffoldArtifact({
  kind,
  name,
  namespace,
  baseDir,
  dryRun = false,
  addIndex = false,
  explicitId,
  force = false,
}: ArtifactArgs): Promise<{
  filePath: string;
  id: string;
  relDir: string;
  exported: boolean;
  content?: string;
}> {
  const cwd = process.cwd();
  const kebab = toKebabCase(name);
  const camel = toCamelCase(name);
  const pascal = toPascalCase(name);

  const id =
    explicitId ||
    `${namespace}.${
      kind === "resource"
        ? "resources"
        : kind === "task"
        ? "tasks"
        : kind === "event"
        ? "events"
        : kind === "hook"
        ? "hooks"
        : kind === "tag"
        ? "tags"
        : kind === "task-middleware" || kind === "resource-middleware"
        ? "middleware"
        : kind
    }.${kebab}`;

  // Build directory as: <baseDir>/<namespace segments>/<type-collection>
  const nsSegments = namespace
    .split(".")
    .map((s) => toKebabCase(s))
    .filter(Boolean);
  const typeCollection =
    kind === "resource"
      ? "resources"
      : kind === "task"
      ? "tasks"
      : kind === "event"
      ? "events"
      : kind === "hook"
      ? "hooks"
      : kind === "tag"
      ? "tags"
      : kind === "task-middleware"
      ? path.join("middleware", "task")
      : path.join("middleware", "resource");

  const relDir = path.join(baseDir, ...nsSegments, typeCollection);

  // File naming convention: <name>.<kind>.ts (eg: create-user.task.ts)
  const fileSuffix =
    kind === "resource"
      ? "resource.ts"
      : kind === "task"
      ? "task.ts"
      : kind === "event"
      ? "event.ts"
      : kind === "hook"
      ? "hook.ts"
      : kind === "tag"
      ? "tag.ts"
      : kind === "task-middleware"
      ? "task-middleware.ts"
      : "resource-middleware.ts";

  const filePath = path.join(cwd, relDir, `${kebab}.${fileSuffix}`);
  const header = `/**\n * Generated by runner-dev new ${kind} ${name}\n * - Namespace: ${namespace}\n * - File: ${path.relative(
    cwd,
    filePath
  )}\n */`;
  const content =
    kind === "resource"
      ? resourceTemplate({ header, id, camel, pascal })
      : kind === "task"
      ? taskTemplate({ header, id, camel, pascal })
      : kind === "event"
      ? eventTemplate({ header, id, camel, pascal })
      : kind === "hook"
      ? hookTemplate({ header, id, camel, pascal })
      : kind === "tag"
      ? tagTemplate({ header, id, camel, pascal })
      : kind === "task-middleware"
      ? taskMiddlewareTemplate({ header, id, camel, pascal })
      : resourceMiddlewareTemplate({ header, id, camel, pascal });

  if (dryRun) {
    return { filePath, id, relDir, exported: false, content };
  }

  await fsp.mkdir(path.dirname(filePath), { recursive: true });
  // Protect against overwriting existing files unless forced
  if (!force && fs.existsSync(filePath)) {
    throw new Error(
      `Refusing to overwrite existing file: ${path.relative(
        cwd,
        filePath
      )} (use --force to override)`
    );
  }
  await fsp.writeFile(filePath, content, { encoding: "utf8" });

  let exported = false;
  if (addIndex) {
    const indexPath = path.join(cwd, relDir, "index.ts");
    const exportPath = `${kebab}.${fileSuffix.replace(/\.ts$/, "")}`;
    const exportLine = `export * from './${exportPath}';\n`;
    try {
      const existing = fs.existsSync(indexPath)
        ? await fsp.readFile(indexPath, "utf8")
        : "";
      if (!existing.includes(exportLine)) {
        await fsp.appendFile(indexPath, exportLine, { encoding: "utf8" });
      }
      exported = true;
    } catch {
      exported = false;
    }
  }

  return { filePath, id, relDir, exported };
}
